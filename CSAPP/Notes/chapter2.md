---
author:
- yinxuhao \[xuhao_yin@163.com\]
date: 2022-12-19
title: 第二单元学习笔记
---

信息的表示和处理

# 引言

孤立地讲，**单个的位不是非常有用，将位组合在一起，再加上某种解释
(interpretation)，即赋予不同的可能位模式以含意**。我们就能表示任何有限
集合的元素。

三种重要的数字表示：

1\. **无符号**`unsigned`编码给予传统的二进制表示法

2\. **补码**`two's-complement`编码是表示有符号整数的最常见的方式。

3\.
**浮点数**`floating-point`编码是表示实数的科学计数法的以2为基数的版本。

数据**溢出**`overflow`是产生bug的一大原因。负数下溢产生极大的正数；
正数上溢产生极小的负数。

浮点运算有完全不同的数学属性。

1\. **由于表示的精度有限，浮点运算是不可结合的**。 例如
$$(3.14+1e_{20})-1e_{20} = 0.0$$ but $$(3.14+1e_{20}-1e_{20}) = 3.14$$

2\. 该属性不同的原因，是处理数字表示有限性的方式不同------

*书中建议的本章学习方式*：

[深入学习数学语言]{.underline}

[学习编写公式和方程式]{.underline}

[以及重要属性的推导]{.underline}

# 信息存储

大多数计算机**使用8位的块或者字节作为最小的可寻址内存单位**，而不是内存
中单独的比特。

机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存**，所有可能
的地址的集合称为**虚拟地址空间**`virtual address space`.

每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。

## 十六进制表示法

![](hex_number.png){#fig:hex_number-png width="80%"}

十六进制转二进制： 将十六进制的每一位转换为二进制格式，然后拼接。 例如：

  ---------- ------ ------ ------ ------ ------ ------
  十六进制        1      7      3      A      4      C
  二进制       0001   0111   0011   1010   0100   1100
  ---------- ------ ------ ------ ------ ------ ------

所以$binary_{0x173a4c_{16}} = 000101110011101001001100_2$。

二进制转十六进制：
将二进制从右到左做4个一组的划分，如最左侧不足4位则以0补之。
然后将每个4位转换为对应的十六进制数字拼接即可。 例如：

  ---------- ---- ------ ------ ------ ------ ------
  二进制       11   1100   1010   1101   1011   0011
  十六进制      3      C      A      D      B      3
  ---------- ---- ------ ------ ------ ------ ------

所以，$hex_{1111001010110110110011_2} = 3cadb3_{16}$

## 字数据大小

每台计算机都有一个字长，指明指针数据的标称大小。

C数据类型的典型大小见下图：

![基本C数据类型的典型大小(以字节为单位)](size.png){#fig:size-png
width="80%"}

## 寻址和字节顺序

**小端法**`little endian`: 最低有效字节在最前面放着。

**大端法**`big endian`: 最高有效字节在最前面放着。

具体示例见下图：

![大端法与小端法](endian.png){#fig:endian-png width="80%"}

``` C
    #include <stdio.h>

    typedef unsigned char *byte_pointer;

    void show_bytes(byte_pointer start, size_t len) {
        size_t i;
        for(i = 0; i < len; i++) {
            printf(" %.2x", start[i]);
        }
        printf("\n");
     }

     void show_int(int x) {
        show_bytes((byte_pointer) &x, sizeof(int));
    }

    void show_float(float x);

    void show_pointer(void *x);

    void test_show_bytes(int val) {
        int ival = val;
        float fval = (float) val;
        int *pval = &ival;
        show_int(ival);
        show_float(fval);
        show_pointer(pval);
    }
```

通过以上代码，可以打印出数据的两位十六进制格式输出。
对比结果可以发现，`int`和`float`的结果一样，只是排列的
大小端不同，而指针值不同，与机器相关。

二进制代码是不兼容的。

## 布尔代数

![布尔代数的运算。二进制0和1代表逻辑值TRUE和FALSE.
以上四张图依次是逻辑运算符NOT AND OR
EXCLUSIVE-OR](bitwise.png){#fig:bitwise-png width="80%"}

位向量一个很有用的应用就是**表示有限集合**。利用位向量
$[a_{w-1}, \ldots, a_1, a_0]$可以编码任何子集$A \in {0, 1, \ldots, w - 1}$。

例如，定义规则$a_i = 1 \iff i \in A$。

位向量$a \dot{=} [01101001]$表示集合$A = {0, 3, 5, 6}$，
而位向量$b \dot{=} [01010101]$表示集合$B = {0, 2, 4, 6}$。

编码集合的使用方法是使用布尔运算。

例如：$a \& b \rightarrow [010000001]$, 对应于$A \cap B = {0, 6}$。

它的实际应用，还有使用位向量作为掩码有选择地使用或屏蔽一些信号，
该掩码就是设置为有效信号的集合。

C语言中的位级运算，其实是按照各个位对应的位运算来的。

而C语言中的逻辑运算(\|\|、`&&`、`!`)则是把所有的
非零参数都表示TRUE，参数0表示为FALSE。它们只返回1或0.
而位级运算只在参数特殊时才与之有相同的结果。

## 移位运算

`x<<k`: 左移k位，即丢弃最高k位，右端补充k个0.

`x>>k`: 右移k位，支持逻辑右移和算术右移。
逻辑右移在左端补充k个0，算术右移则在左端补充k个最高有效位(符号位)。

**对无符号数，右移必须是逻辑的**。

**移位运算符是从左至右可结合的**。

# 整数表示

![整数的数据与算术操作术语。下标w表示数据中表示中的位数](terms.png){#fig:terms-png
width="80%"}
