---
author:
- yinxuhao \[xuhao_yin@163.com\]
date: 2022-12-21
title: 第二单元学习笔记
---

信息的表示和处理

# 引言

孤立地讲，**单个的位不是非常有用，将位组合在一起，再加上某种解释
(interpretation)，即赋予不同的可能位模式以含意**。我们就能表示任何有限
集合的元素。

三种重要的数字表示：

1\. **无符号**`unsigned`编码给予传统的二进制表示法

2\. **补码**`two's-complement`编码是表示有符号整数的最常见的方式。

3\.
**浮点数**`floating-point`编码是表示实数的科学计数法的以2为基数的版本。

数据**溢出**`overflow`是产生bug的一大原因。负数下溢产生极大的正数；
正数上溢产生极小的负数。

浮点运算有完全不同的数学属性。

1\. **由于表示的精度有限，浮点运算是不可结合的**。 例如
$$(3.14+1e_{20})-1e_{20} = 0.0$$ but $$(3.14+1e_{20}-1e_{20}) = 3.14$$

2\. 该属性不同的原因，是处理数字表示有限性的方式不同------

*书中建议的本章学习方式*：

[深入学习数学语言]{.underline}

[学习编写公式和方程式]{.underline}

[以及重要属性的推导]{.underline}

# 信息存储

大多数计算机**使用8位的块或者字节作为最小的可寻址内存单位**，而不是内存
中单独的比特。

机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存**，所有可能
的地址的集合称为**虚拟地址空间**`virtual address space`.

每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。

## 十六进制表示法

![](hex_number.png){#fig:hex_number-png width="80%"}

十六进制转二进制： 将十六进制的每一位转换为二进制格式，然后拼接。 例如：

  ---------- ------ ------ ------ ------ ------ ------
  十六进制        1      7      3      A      4      C
  二进制       0001   0111   0011   1010   0100   1100
  ---------- ------ ------ ------ ------ ------ ------

所以$binary_{0x173a4c_{16}} = 000101110011101001001100_2$。

二进制转十六进制：
将二进制从右到左做4个一组的划分，如最左侧不足4位则以0补之。
然后将每个4位转换为对应的十六进制数字拼接即可。 例如：

  ---------- ---- ------ ------ ------ ------ ------
  二进制       11   1100   1010   1101   1011   0011
  十六进制      3      C      A      D      B      3
  ---------- ---- ------ ------ ------ ------ ------

所以，$hex_{1111001010110110110011_2} = 3cadb3_{16}$

## 字数据大小

每台计算机都有一个字长，指明指针数据的标称大小。

C数据类型的典型大小见下图：

![基本C数据类型的典型大小(以字节为单位)](size.png){#fig:size-png
width="80%"}

## 寻址和字节顺序

**小端法**`little endian`: 最低有效字节在最前面放着。

**大端法**`big endian`: 最高有效字节在最前面放着。

具体示例见下图：

![大端法与小端法](endian.png){#fig:endian-png width="80%"}

``` C
    #include <stdio.h>

    typedef unsigned char *byte_pointer;

    void show_bytes(byte_pointer start, size_t len) {
        size_t i;
        for(i = 0; i < len; i++) {
            printf(" %.2x", start[i]);
        }
        printf("\n");
     }

     void show_int(int x) {
        show_bytes((byte_pointer) &x, sizeof(int));
    }

    void show_float(float x);

    void show_pointer(void *x);

    void test_show_bytes(int val) {
        int ival = val;
        float fval = (float) val;
        int *pval = &ival;
        show_int(ival);
        show_float(fval);
        show_pointer(pval);
    }
```

通过以上代码，可以打印出数据的两位十六进制格式输出。
对比结果可以发现，`int`和`float`的结果一样，只是排列的
大小端不同，而指针值不同，与机器相关。

二进制代码是不兼容的。

## 布尔代数

![布尔代数的运算。二进制0和1代表逻辑值TRUE和FALSE.
以上四张图依次是逻辑运算符NOT AND OR
EXCLUSIVE-OR](bitwise.png){#fig:bitwise-png width="80%"}

位向量一个很有用的应用就是**表示有限集合**。利用位向量
$[a_{w-1}, \ldots, a_1, a_0]$可以编码任何子集$A \in {0, 1, \ldots, w - 1}$。

例如，定义规则$a_i = 1 \iff i \in A$。

位向量$a \dot{=} [01101001]$表示集合$A = {0, 3, 5, 6}$，
而位向量$b \dot{=} [01010101]$表示集合$B = {0, 2, 4, 6}$。

编码集合的使用方法是使用布尔运算。

例如：$a \& b \rightarrow [010000001]$, 对应于$A \cap B = {0, 6}$。

它的实际应用，还有使用位向量作为掩码有选择地使用或屏蔽一些信号，
该掩码就是设置为有效信号的集合。

C语言中的位级运算，其实是按照各个位对应的位运算来的。

而C语言中的逻辑运算(\|\|、`&&`、`!`)则是把所有的
非零参数都表示TRUE，参数0表示为FALSE。它们只返回1或0.
而位级运算只在参数特殊时才与之有相同的结果。

## 移位运算

`x<<k`: 左移k位，即丢弃最高k位，右端补充k个0.

`x>>k`: 右移k位，支持逻辑右移和算术右移。
逻辑右移在左端补充k个0，算术右移则在左端补充k个最高有效位(符号位)。

**对无符号数，右移必须是逻辑的**。

**移位运算符是从左至右可结合的**。

# 整数表示

![整数的数据与算术操作术语。下标w表示数据中表示中的位数](terms.png){#fig:terms-png
width="80%"}

## 无符号数的编码

::: theorem
**原理 1**. *无符号数编码的定义*

*对向量$\vec{x} = [x_{w-1}, x_{w-2}, \ldots, x_{0}]$:
$$B2U_w(\vec{x}) \dot{=} \sum_{i=0}^{w-1}x_i2^i$$*
:::

::: theorem
**原理 2**. *无符号数编码的唯一性*

*函数$B2U_w$是一个双射*
:::

## 补码编码

::: theorem
**原理 3**. *补码编码的定义*

*对向量$\vec{x} = [x_{w-1}, x_{w-2}, \ldots, x_0]$:
$$B2T_w(\vec{x}) \dot{=} -x_{w-1}2^{w-1} + \sum_{i=0}^{w-2}x_i2^i$$*
:::

::: theorem
**原理 4**. *补码编码的唯一性*

*函数$B2T_w$是一个双射。*
:::

1\.
补码的范围是不对称的：$|TMin| = |TMax| + 1$，即TMin没有与之对应的正数。
这是因为0是非负数。

2\. 最大的无符号数值刚好比补码的最大值的两倍大一点：$UMax_w = 2TMax_w+1$

## 有符号和无符号数之间的转换

::: theorem
**原理 5**. *补码转换为无符号数*

*对满足$TMin_w \le x \le TMax_w$的x有： $$T2U_w(x) = \left\{
            \begin{array}{ll}
                x+2^w, & x < 0 \\
                x, & x\ge 0
            \end{array}
        \right.$$*
:::

::: theorem
**原理 6**. *无符号数转换为补码*

*对满足$0 \le x \le UMax_w$的u有： $$U2T_w(u) = \left\{
            \begin{array}{ll}
                u, & u \le TMax_w \\
                u-2^w, & u >TMax
            \end{array}
            \right.$$*
:::

## 扩展一个数字的位表示

用于将数据类型转换为一个更大的数据类型，例如32位$\rightarrow$`<!-- -->`{=html}64位。

::: theorem
**原理 7**. *无符号数的零扩展*

*定义宽度为w的位向量$\vec{u} = [u_{w-1}, u_{w-2}, \ldots, u_0]$和宽度为
$w^{\prime}$的位向量$\vec{u}^{\prime} = [\textcolor{blue}{0, \ldots, 0}, u_{w-1}, u_{w-1},
        \ldots, u_0]$，其中，$w^{\prime} > w$。则$B2U_w(\vec{u}) = B2U_{w^{\prime}}(\vec{u}^{\prime})$。*
:::

::: theorem
**原理 8**. *补码数的符号扩展*

*定义宽度为w的位向量$\vec{x} = [\textcolor{blue}{x_{w-1}}, x_{w-2}, \ldots, x_0]$
和宽度为w的位向量$\vec{x}^{\prime} = [\textcolor{blue}{x_{w-1}, \ldots, x_{w-1}, x_{w-1}}, x_{w-2}, \ldots, x_0]$，其中$w^{\prime} > w$。则$B2T_w(\vec{x}) = B2T_{w^{\prime}}(\vec{x}^{\prime})$。*
:::
